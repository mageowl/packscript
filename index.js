import fs from "fs-extra";
import chalk from "chalk";
import path from "path";

import { keywords, events, customCmds } from "./src/constants.js";

const filePath = process.argv[2];

fs.readFile(filePath, "utf8").then((data) => {
	const lines = data.split("\n");

	let block = [];
	let codeBlock = [];
	let failed = false;
	let prefix = "";
	let inPack;
	let packFile = {};

	let currentNamespace;
	let currentFilePath = "none";
	let files = {
		"packscript/functions/tick.mcfunction":
			"# Generated by the PackScript compiler\n"
	};
	let tags = {};

	lines.forEach((line, i) => {
		if (failed) return;

		let isBlock = false;
		let isCodeBlock = false;
		let blockName = [];

		if (line.slice(-1) == "{") {
			let value = line.slice(0, -1).trim();
			if (keywords.includes(value.split(" ")[0])) {
				block.push(value);
				isBlock = true;
				blockName = [value.split(" ")[0], value.split(" ").slice(1)];
			} else {
				codeBlock = [
					value.split("(")[0],
					value.split("(").slice(1)[0].slice(0, value.indexOf(")"))
				];
				isCodeBlock = true;
			}
		} else if (line.slice(-1) == "}" && line.slice(0, 1) != "/") {
			if (codeBlock.length == 0) {
				switch (block.slice(-1)[0].split(" ")[0]) {
					case "pack":
						inPack = false;
						break;

					case "on":
					case "function":
					case "raycast":
						currentFilePath = "none";
						break;

					default:
						break;
				}

				block.pop();
				blockName = [];
			} else {
				switch (codeBlock[0]) {
					case "asat":
						prefix = "";
						break;

					default:
						break;
				}

				codeBlock = [];
			}

			isBlock = true;
			return;
		}

		if (inPack && !isBlock) {
			let splitLine = line.split(":");
			packFile[splitLine[0].trim()] = splitLine[1].trim();
			return;
		}

		if (currentFilePath == "none" && !isBlock && !line.trim() == "") {
			console.log(
				chalk.red(
					`PackScript Error (line ${
						i + 1
					}): Code must be placed inside a function.`
				)
			);
			failed = true;
			return;
		}

		if (isBlock && blockName.length != 0) {
			switch (blockName[0]) {
				case "on":
					let event = blockName[1][0].split(":");
					if (
						events[event[0]] != undefined &&
						Object.keys(events[event[0]]).includes(event[1])
					) {
						let eventFile = events[event[0]][event[1]];

						if (tags[eventFile] == undefined) tags[eventFile] = [];

						currentFilePath =
							currentNamespace +
							"/functions/" +
							blockName[1][1] +
							".mcfunction";
						tags[eventFile].push(
							currentNamespace +
								":" +
								currentFilePath.slice(currentNamespace.length + 11, -11)
						);
					} else {
						console.log(
							chalk.red(
								`PackScript Error (line ${i + 1}): Unknown event \"${
									blockName[1][0]
								}\".`
							)
						);
						failed = true;
						return;
					}
					break;

				case "pack":
					inPack = true;
					break;

				case "namespace":
					currentFilePath = "none";
					currentNamespace = blockName[1][0];
					break;

				case "raycast":
					let name = blockName[1][0];

					currentFilePath =
						"packscript/functions/raycast/" + name + ".mcfunction";

					files[
						"packscript/functions/raycast/" + name + "_start.mcfunction"
					] = `# Generated by the PackScript compiler\n\nexecute anchored eyes positioned ^ ^ ^1 run function packscript:raycast/${name}`;
					files[
						currentFilePath
					] = `# Generated by the PackScript compiler\n\nexecute unless block ^ ^ ^1 air if entity @e[distance=0..0.8] run function #${currentNamespace}:${name}_hit\nexecute if block ~ ~ ~ air unless entity @e[distance=0..0.8] positioned ^ ^ ^1 run function packscript:raycast/${name}`;
					events.ray_hit[
						name
					] = `${currentNamespace}/tags/functions/${name}_hit.json`;
					break;

				case "function":
					currentFilePath =
						currentNamespace + "/functions/" + blockName[1][0] + ".mcfunction";
					break;

				default:
					break;
			}

			return;
		}

		if (isCodeBlock && codeBlock.length != 0) {
			switch (codeBlock[0]) {
				case "asat":
					let selector = codeBlock[1]
						.slice(0, -1)
						.replace(/\?([^}]+)/g, "$1=1..");
					prefix = prefix + `execute as ${selector} at @s run `;
					break;

				default:
					break;
			}

			return;
		}

		if (line.trim().substr(0, 1) == "/") {
			if (files[currentFilePath] == undefined) {
				files[currentFilePath] = "# Generated by the PackScript compiler\n";
			}
			files[currentFilePath] += `\n${prefix}${line.trim().slice(1)}`;
			return;
		} else if (customCmds.includes(line.trim().split(" ")[0])) {
			if (files[currentFilePath] == undefined)
				files[currentFilePath] = "# Generated by the PackScript compiler\n";
			let cmd = [line.trim().split(" ")[0], line.trim().split(" ").slice(1)];

			switch (cmd[0]) {
				case "trigger":
					if (cmd[1][0].slice(-1) != ":") {
						console.log(
							chalk.red(
								`PackScript Error (line ${
									i + 1
								}): Expected ":". Instead found ${cmd[1][1]}.`
							)
						);
						failed = true;
						return;
					}

					files[
						currentFilePath
					] += `\n${prefix}scoreboard objectives add ${cmd[1][0].slice(
						0,
						-1
					)} ${cmd[1][1]}`;
					files[
						"packscript/functions/tick.mcfunction"
					] += `\nscoreboard players set @a ${cmd[1][0].slice(0, -1)} 0`;
					break;

				case "cast":
					if (files[currentFilePath] == undefined)
						files[currentFilePath] = "# Generated by the PackScript compiler\n";
					files[
						currentFilePath
					] += `\n${prefix}function packscript:raycast/${cmd[1]}-start`;
					break;

				default:
					break;
			}
		}
	});

	if (tags[events.mc.tick] == undefined) tags[events.mc.tick] = [];
	tags[events.mc.tick].push("packscript:tick");

	let packPath = `${packFile.path}/${packFile.name}`;

	fs.remove(packPath).then(() => {
		fs.mkdir(packPath).then(() => {
			fs.mkdir(packPath + "/data").then(() => {
				Object.entries(files).forEach((file) => {
					fs.mkdirp(path.dirname(packPath + "/data/" + file[0])).then(() => {
						fs.writeFile(packPath + "/data/" + file[0], file[1]);
					});
				});
				Object.entries(tags).forEach((tag) => {
					fs.mkdirp(path.dirname(packPath + "/data/" + tag[0])).then(() => {
						fs.writeFile(
							packPath + "/data/" + tag[0],
							JSON.stringify({ values: tag[1] })
						);
					});
				});
			});
			fs.writeFile(
				packPath + "/pack.mcmeta",
				JSON.stringify({
					pack: {
						description: packFile.description,
						pack_format: 6
					}
				})
			);
		});
	});
});
